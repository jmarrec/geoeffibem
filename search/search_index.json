{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#geomeffibem","title":"GeomEffiBEM","text":"<p>A small library to facilitate some building energy modeling geometry operations with OpenStudio and EnergyPlus in mind. This started as a test bed while I was implementing source code changes to both aforementioned projects and I realized this had value in creating geometry in an efficient manner as well as being able to visualize simple geometry in 2D via matplotlib.</p> <p>A Jupyter Notebook GeomEffiBEM_Demonstration.ipynb can serve as a small demonstration of the features.</p> <ul> <li>Documentation: https://jmarrec.github.io/geomeffibem</li> <li>GitHub: https://github.com/jmarrec/geomeffibem</li> <li>PyPI: https://pypi.org/project/geomeffibem/</li> </ul> <p>This is free software (MIT License) contributed by EffiBEM.</p> <p>Leveraging software, EffiBEM specializes in providing new ways to streamline your workflows and create new tools that work with limited inputs for your specific applications. We also offer support and training services on BEM simulation engines (OpenStudio and EnergyPlus).</p>"},{"location":"api/","title":"Modules","text":""},{"location":"api/#vertex","title":"Vertex","text":"<p>Vertex and Vertex related functions.</p> <p>A Vertex is a 3-coordinate class, that can be used to represent a Point3d or a Vector3d Includes utilities to go from/to numpy array and OpenStudio's Point3d</p>"},{"location":"api/#geomeffibem.vertex.Vertex","title":"<code>Vertex</code>","text":"<p>Point3d and Vector3d.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>class Vertex:\n    \"\"\"Point3d and Vector3d.\"\"\"\n\n    @staticmethod\n    def from_numpy(arr):\n        \"\"\"Factory method to construct from a numpy array (or a list) of 3 coords.\"\"\"\n        if not isinstance(arr, np.ndarray):\n            arr = np.array(arr)\n        if arr.shape != (3,):\n            raise ValueError(f\"Expected a numpy array with a dimension (3, ) (a Vector3d), got {arr.shape}\")\n        return Vertex(arr[0], arr[1], arr[2])\n\n    @staticmethod\n    def from_Point3d(pt: openstudio.Point3d):\n        \"\"\"Factory method to construct from an openstudio.Point3d.\"\"\"\n        return Vertex(pt.x(), pt.y(), pt.z())\n\n    def __init__(self, x, y, z):\n        \"\"\"Vertex constructor.\"\"\"\n        self.x = x\n        self.y = y\n        self.z = z\n        self.surface = None\n\n    def copy(self):\n        \"\"\"Make a copy of this Vertex.\"\"\"\n        return Vertex(self.x, self.y, self.z)\n\n    def get_coords_on_plane(self, plane='xy') -&gt; Tuple[float, float]:\n        \"\"\"Returns two coordinates on a given plane.\"\"\"\n        if plane == 'xy':\n            return self.x, self.y\n        elif plane == 'xz':\n            return self.x, self.z\n        elif plane == 'yz':\n            return self.y, self.z\n\n        raise ValueError(\"Expected plane to be 'xy', 'xz' or 'yz'.\")\n\n    def length(self) -&gt; float:\n        \"\"\"Get the length of the vector.\"\"\"\n        return np.sqrt(np.sum(self.to_numpy() ** 2))\n\n    def normalize(self) -&gt; Vertex:\n        \"\"\"Normalize to a length of 1, returns a copy.\"\"\"\n        v = self.copy()\n        v.setLength(1.0)\n        return v\n\n    def setLength(self, newLength: float) -&gt; None:\n        \"\"\"Change length of vector, in place.\"\"\"\n        currentLength = self.length()\n        if currentLength &gt; 0:\n            mult = newLength / currentLength\n            self.x *= mult\n            self.y *= mult\n            self.z *= mult\n        else:\n            raise ValueError(\"Cannot normalize a vector of length 0\")\n\n    def dot(self, other) -&gt; float:\n        \"\"\"Computes the dot / scalar / inner product product of two vectors.\n\n        (a.b).\n        \"\"\"\n        # return np.dot(v.to_numpy(), v2.to_numpy())\n        return self.x * other.x + self.y * other.y + self.z * other.z\n\n    def cross(self, other, normalize: bool = False) -&gt; Vertex:\n        \"\"\"Computes the cross product (a x b), which is a vector perpendicular to both a and b.\"\"\"\n        v = Vertex(\n            x=(self.y * other.z - self.z * other.y),\n            y=(self.z * other.x - self.x * other.z),\n            z=(self.x * other.y - self.y * other.x),\n        )\n        if normalize:\n            return v.normalize()\n        return v\n\n    def outer_product(self, other) -&gt; np.ndarray:\n        \"\"\"Compute the outer product of this by another vector.\"\"\"\n        return np.outer(self.to_numpy(), other.to_numpy())\n\n    def __add__(self, other) -&gt; Vertex:\n        \"\"\"Return a + b.\"\"\"\n        return Vertex(x=self.x + other.x, y=self.y + other.y, z=self.z + other.z)\n\n    def __neg__(self):\n        \"\"\"Return obj negated (-obj).\"\"\"\n        return Vertex(-self.x, -self.y, -self.z)\n\n    def __sub__(self, other) -&gt; Vertex:\n        \"\"\"Return a - b.\"\"\"\n        return self + -other\n        # return Vertex(\n        #     x=self.x - other.x,\n        #     y=self.y - other.y,\n        #     z=self.z - other.z\n        # )\n\n    def __mul__(self, other) -&gt; Vertex:\n        \"\"\"Multiplies each coordinate by a scalar.\"\"\"\n        if not isinstance(other, int) and not isinstance(other, float):\n            raise ValueError(\"Multiplication of a vertex by something else than a numeric is not supported\")\n        return Vertex(self.x * other, self.y * other, self.z * other)\n\n    def __rmul__(self, other) -&gt; Vertex:\n        \"\"\"Multiplies each coordinate by a scalar.\"\"\"\n        if not isinstance(other, int) and not isinstance(other, float):\n            raise ValueError(\"Multiplication of a vertex by something else than a numeric is not supported\")\n        return self.__mul__(other)\n\n    def __truediv__(self, other) -&gt; Vertex:\n        \"\"\"Divides each coordinate by a scalar.\"\"\"\n        if not isinstance(other, int) and not isinstance(other, float):\n            raise ValueError(\"Division of a vertex by something else than a numeric is not supported\")\n        return Vertex(self.x / other, self.y / other, self.z / other)\n\n    def __floordiv__(self, other) -&gt; Vertex:\n        \"\"\"Divides each coordinate by a scalar.\"\"\"\n        if not isinstance(other, int) and not isinstance(other, float):\n            raise ValueError(\"Division of a vertex by something else than a numeric is not supported\")\n        return Vertex(self.x // other, self.y // other, self.z // other)\n\n    def to_numpy(self) -&gt; np.ndarray:\n        \"\"\"Export to a numpy array of 3 coordinates.\"\"\"\n        return np.array([self.x, self.y, self.z])\n\n    def to_Point3d(self) -&gt; openstudio.Point3d:\n        \"\"\"Export to an openstudio.Point3d.\"\"\"\n        return openstudio.Point3d(self.x, self.y, self.z)\n\n    def __eq__(self, other):\n        \"\"\"Operator equal. Raises if not passed a Vertex.\"\"\"\n        if not isinstance(other, Vertex):\n            raise NotImplementedError(\"Not implemented for any other types than Vertex itself\")\n        return isAlmostEqual3dPt(self, other)\n\n    def __ne__(self, other):\n        \"\"\"Operator not equal.\"\"\"\n        return not self == other\n\n    def __repr__(self):\n        \"\"\"Repr.\"\"\"\n        # return f\"({self.x}, {self.y}, {self.z})\"\n        return f\"({self.x:+.4f}, {self.y:+.4f}, {self.z:+.4f})\"\n</code></pre>"},{"location":"api/#geomeffibem.vertex.Vertex.__add__","title":"<code>__add__(other)</code>","text":"<p>Return a + b.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def __add__(self, other) -&gt; Vertex:\n    \"\"\"Return a + b.\"\"\"\n    return Vertex(x=self.x + other.x, y=self.y + other.y, z=self.z + other.z)\n</code></pre>"},{"location":"api/#geomeffibem.vertex.Vertex.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Operator equal. Raises if not passed a Vertex.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Operator equal. Raises if not passed a Vertex.\"\"\"\n    if not isinstance(other, Vertex):\n        raise NotImplementedError(\"Not implemented for any other types than Vertex itself\")\n    return isAlmostEqual3dPt(self, other)\n</code></pre>"},{"location":"api/#geomeffibem.vertex.Vertex.__floordiv__","title":"<code>__floordiv__(other)</code>","text":"<p>Divides each coordinate by a scalar.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def __floordiv__(self, other) -&gt; Vertex:\n    \"\"\"Divides each coordinate by a scalar.\"\"\"\n    if not isinstance(other, int) and not isinstance(other, float):\n        raise ValueError(\"Division of a vertex by something else than a numeric is not supported\")\n    return Vertex(self.x // other, self.y // other, self.z // other)\n</code></pre>"},{"location":"api/#geomeffibem.vertex.Vertex.__init__","title":"<code>__init__(x, y, z)</code>","text":"<p>Vertex constructor.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def __init__(self, x, y, z):\n    \"\"\"Vertex constructor.\"\"\"\n    self.x = x\n    self.y = y\n    self.z = z\n    self.surface = None\n</code></pre>"},{"location":"api/#geomeffibem.vertex.Vertex.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Multiplies each coordinate by a scalar.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def __mul__(self, other) -&gt; Vertex:\n    \"\"\"Multiplies each coordinate by a scalar.\"\"\"\n    if not isinstance(other, int) and not isinstance(other, float):\n        raise ValueError(\"Multiplication of a vertex by something else than a numeric is not supported\")\n    return Vertex(self.x * other, self.y * other, self.z * other)\n</code></pre>"},{"location":"api/#geomeffibem.vertex.Vertex.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Operator not equal.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def __ne__(self, other):\n    \"\"\"Operator not equal.\"\"\"\n    return not self == other\n</code></pre>"},{"location":"api/#geomeffibem.vertex.Vertex.__neg__","title":"<code>__neg__()</code>","text":"<p>Return obj negated (-obj).</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def __neg__(self):\n    \"\"\"Return obj negated (-obj).\"\"\"\n    return Vertex(-self.x, -self.y, -self.z)\n</code></pre>"},{"location":"api/#geomeffibem.vertex.Vertex.__repr__","title":"<code>__repr__()</code>","text":"<p>Repr.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def __repr__(self):\n    \"\"\"Repr.\"\"\"\n    # return f\"({self.x}, {self.y}, {self.z})\"\n    return f\"({self.x:+.4f}, {self.y:+.4f}, {self.z:+.4f})\"\n</code></pre>"},{"location":"api/#geomeffibem.vertex.Vertex.__rmul__","title":"<code>__rmul__(other)</code>","text":"<p>Multiplies each coordinate by a scalar.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def __rmul__(self, other) -&gt; Vertex:\n    \"\"\"Multiplies each coordinate by a scalar.\"\"\"\n    if not isinstance(other, int) and not isinstance(other, float):\n        raise ValueError(\"Multiplication of a vertex by something else than a numeric is not supported\")\n    return self.__mul__(other)\n</code></pre>"},{"location":"api/#geomeffibem.vertex.Vertex.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Return a - b.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def __sub__(self, other) -&gt; Vertex:\n    \"\"\"Return a - b.\"\"\"\n    return self + -other\n</code></pre>"},{"location":"api/#geomeffibem.vertex.Vertex.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Divides each coordinate by a scalar.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def __truediv__(self, other) -&gt; Vertex:\n    \"\"\"Divides each coordinate by a scalar.\"\"\"\n    if not isinstance(other, int) and not isinstance(other, float):\n        raise ValueError(\"Division of a vertex by something else than a numeric is not supported\")\n    return Vertex(self.x / other, self.y / other, self.z / other)\n</code></pre>"},{"location":"api/#geomeffibem.vertex.Vertex.copy","title":"<code>copy()</code>","text":"<p>Make a copy of this Vertex.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def copy(self):\n    \"\"\"Make a copy of this Vertex.\"\"\"\n    return Vertex(self.x, self.y, self.z)\n</code></pre>"},{"location":"api/#geomeffibem.vertex.Vertex.cross","title":"<code>cross(other, normalize=False)</code>","text":"<p>Computes the cross product (a x b), which is a vector perpendicular to both a and b.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def cross(self, other, normalize: bool = False) -&gt; Vertex:\n    \"\"\"Computes the cross product (a x b), which is a vector perpendicular to both a and b.\"\"\"\n    v = Vertex(\n        x=(self.y * other.z - self.z * other.y),\n        y=(self.z * other.x - self.x * other.z),\n        z=(self.x * other.y - self.y * other.x),\n    )\n    if normalize:\n        return v.normalize()\n    return v\n</code></pre>"},{"location":"api/#geomeffibem.vertex.Vertex.dot","title":"<code>dot(other)</code>","text":"<p>Computes the dot / scalar / inner product product of two vectors.</p> <p>(a.b).</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def dot(self, other) -&gt; float:\n    \"\"\"Computes the dot / scalar / inner product product of two vectors.\n\n    (a.b).\n    \"\"\"\n    # return np.dot(v.to_numpy(), v2.to_numpy())\n    return self.x * other.x + self.y * other.y + self.z * other.z\n</code></pre>"},{"location":"api/#geomeffibem.vertex.Vertex.from_Point3d","title":"<code>from_Point3d(pt)</code>  <code>staticmethod</code>","text":"<p>Factory method to construct from an openstudio.Point3d.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>@staticmethod\ndef from_Point3d(pt: openstudio.Point3d):\n    \"\"\"Factory method to construct from an openstudio.Point3d.\"\"\"\n    return Vertex(pt.x(), pt.y(), pt.z())\n</code></pre>"},{"location":"api/#geomeffibem.vertex.Vertex.from_numpy","title":"<code>from_numpy(arr)</code>  <code>staticmethod</code>","text":"<p>Factory method to construct from a numpy array (or a list) of 3 coords.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>@staticmethod\ndef from_numpy(arr):\n    \"\"\"Factory method to construct from a numpy array (or a list) of 3 coords.\"\"\"\n    if not isinstance(arr, np.ndarray):\n        arr = np.array(arr)\n    if arr.shape != (3,):\n        raise ValueError(f\"Expected a numpy array with a dimension (3, ) (a Vector3d), got {arr.shape}\")\n    return Vertex(arr[0], arr[1], arr[2])\n</code></pre>"},{"location":"api/#geomeffibem.vertex.Vertex.get_coords_on_plane","title":"<code>get_coords_on_plane(plane='xy')</code>","text":"<p>Returns two coordinates on a given plane.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def get_coords_on_plane(self, plane='xy') -&gt; Tuple[float, float]:\n    \"\"\"Returns two coordinates on a given plane.\"\"\"\n    if plane == 'xy':\n        return self.x, self.y\n    elif plane == 'xz':\n        return self.x, self.z\n    elif plane == 'yz':\n        return self.y, self.z\n\n    raise ValueError(\"Expected plane to be 'xy', 'xz' or 'yz'.\")\n</code></pre>"},{"location":"api/#geomeffibem.vertex.Vertex.length","title":"<code>length()</code>","text":"<p>Get the length of the vector.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def length(self) -&gt; float:\n    \"\"\"Get the length of the vector.\"\"\"\n    return np.sqrt(np.sum(self.to_numpy() ** 2))\n</code></pre>"},{"location":"api/#geomeffibem.vertex.Vertex.normalize","title":"<code>normalize()</code>","text":"<p>Normalize to a length of 1, returns a copy.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def normalize(self) -&gt; Vertex:\n    \"\"\"Normalize to a length of 1, returns a copy.\"\"\"\n    v = self.copy()\n    v.setLength(1.0)\n    return v\n</code></pre>"},{"location":"api/#geomeffibem.vertex.Vertex.outer_product","title":"<code>outer_product(other)</code>","text":"<p>Compute the outer product of this by another vector.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def outer_product(self, other) -&gt; np.ndarray:\n    \"\"\"Compute the outer product of this by another vector.\"\"\"\n    return np.outer(self.to_numpy(), other.to_numpy())\n</code></pre>"},{"location":"api/#geomeffibem.vertex.Vertex.setLength","title":"<code>setLength(newLength)</code>","text":"<p>Change length of vector, in place.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def setLength(self, newLength: float) -&gt; None:\n    \"\"\"Change length of vector, in place.\"\"\"\n    currentLength = self.length()\n    if currentLength &gt; 0:\n        mult = newLength / currentLength\n        self.x *= mult\n        self.y *= mult\n        self.z *= mult\n    else:\n        raise ValueError(\"Cannot normalize a vector of length 0\")\n</code></pre>"},{"location":"api/#geomeffibem.vertex.Vertex.to_Point3d","title":"<code>to_Point3d()</code>","text":"<p>Export to an openstudio.Point3d.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def to_Point3d(self) -&gt; openstudio.Point3d:\n    \"\"\"Export to an openstudio.Point3d.\"\"\"\n    return openstudio.Point3d(self.x, self.y, self.z)\n</code></pre>"},{"location":"api/#geomeffibem.vertex.Vertex.to_numpy","title":"<code>to_numpy()</code>","text":"<p>Export to a numpy array of 3 coordinates.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def to_numpy(self) -&gt; np.ndarray:\n    \"\"\"Export to a numpy array of 3 coordinates.\"\"\"\n    return np.array([self.x, self.y, self.z])\n</code></pre>"},{"location":"api/#geomeffibem.vertex.distance","title":"<code>distance(lhs, rhs)</code>","text":"<p>Distance between two vertices.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def distance(lhs: Vertex, rhs: Vertex) -&gt; float:\n    \"\"\"Distance between two vertices.\"\"\"\n    squared_dist = np.sum((lhs.to_numpy() - rhs.to_numpy()) ** 2, axis=0)\n    dist = np.sqrt(squared_dist)\n    return dist\n</code></pre>"},{"location":"api/#geomeffibem.vertex.distanceFromPointToLine","title":"<code>distanceFromPointToLine(start, end, test)</code>","text":"<p>Distance between a point and a line.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def distanceFromPointToLine(start: Vertex, end: Vertex, test: Vertex) -&gt; np.floating[Any]:\n    \"\"\"Distance between a point and a line.\"\"\"\n    s = start.to_numpy()\n    e = end.to_numpy()\n    p = test.to_numpy()\n    return np.linalg.norm(np.cross(e - s, p - s) / np.linalg.norm(e - s))\n</code></pre>"},{"location":"api/#geomeffibem.vertex.getAngle","title":"<code>getAngle(start, end)</code>","text":"<p>Returns the angle between two vectors, in radians.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def getAngle(start: Vertex, end: Vertex) -&gt; float:\n    \"\"\"Returns the angle between two vectors, in radians.\"\"\"\n    start = start.normalize()\n    end = end.normalize()\n    return np.arccos(start.dot(end))\n</code></pre>"},{"location":"api/#geomeffibem.vertex.getNewellVector","title":"<code>getNewellVector(points)</code>","text":"<p>Compute Newell vector from a list of points, direction is same as outward normal magnitude is twice the area.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def getNewellVector(points: List[Vertex]) -&gt; Vertex:\n    \"\"\"Compute Newell vector from a list of points, direction is same as outward normal magnitude is twice the area.\"\"\"\n    n = len(points)\n    if n &lt; 3:\n        raise ValueError(\"Cannot compute Newell Vector for less than 3 points\")\n\n    newellVector = Vertex(x=0, y=0, z=0)\n    for i in range(n - 1):\n        v1 = points[i] - points[0]\n        v2 = points[i + 1] - points[0]\n        newellVector += v1.cross(v2)\n\n    return newellVector\n</code></pre>"},{"location":"api/#geomeffibem.vertex.getOutwardNormal","title":"<code>getOutwardNormal(points)</code>","text":"<p>Compute outward normal from a list of points.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def getOutwardNormal(points: list[Vertex]) -&gt; Vertex:\n    \"\"\"Compute outward normal from a list of points.\"\"\"\n    newellVector = getNewellVector(points)\n    return newellVector.normalize()\n</code></pre>"},{"location":"api/#geomeffibem.vertex.isAlmostEqual3dPt","title":"<code>isAlmostEqual3dPt(v1, v2, tol=0.0127)</code>","text":"<p>Checks if both vertices almost equal within tolerance.</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def isAlmostEqual3dPt(v1: Vertex, v2: Vertex, tol=0.0127) -&gt; bool:\n    \"\"\"Checks if both vertices almost equal within tolerance.\"\"\"\n    # 0.0127 m = 1.27 cm = 1/2 inch\n    return not (abs((v1.to_numpy() - v2.to_numpy())) &gt;= tol).any()\n</code></pre>"},{"location":"api/#geomeffibem.vertex.isPointOnLineBetweenPoints","title":"<code>isPointOnLineBetweenPoints(start, end, test, tol=0.0127)</code>","text":"<p>Checks whether a Vertex is on a segment.</p> <p>If the distance(start, test) + distance(test, end) == distance(start, end) then it's on a line But we first check that the distance from the point to the line is also inferior to this tolerance</p> Source code in <code>geomeffibem/vertex.py</code> <pre><code>def isPointOnLineBetweenPoints(start: Vertex, end: Vertex, test: Vertex, tol: float = 0.0127) -&gt; bool:\n    \"\"\"Checks whether a Vertex is on a segment.\n\n    If the distance(start, test) + distance(test, end) == distance(start, end) then it's on a line\n    But we first check that the distance from the point to the line is also inferior to this tolerance\n    \"\"\"\n    if distanceFromPointToLine(start=start, end=end, test=test) &lt; tol:\n        return abs(distance(start, end) - (distance(start, test) + distance(test, end))) &lt; tol\n    return False\n</code></pre>"},{"location":"api/#surface","title":"Surface","text":"<p>Surface and Surface3dEdge objects.</p> <p>A Surface is a collection of Vertex. A Surface3dEdge is a side of a Surface.</p>"},{"location":"api/#geomeffibem.surface.Surface","title":"<code>Surface</code>","text":"<p>A 3D Surface.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>class Surface:\n    \"\"\"A 3D Surface.\"\"\"\n\n    @staticmethod\n    def from_numpy_array(arr) -&gt; Surface:\n        \"\"\"Factory method to construct from a numpy array of 3-coordinates arrays.\"\"\"\n        if isinstance(arr, list):\n            arr = np.array(arr)\n        if arr.shape[0] &lt; 3:\n            raise ValueError(\"Need at least 3 vertices to construct a Surface\")\n        if arr.shape[1] != 3:\n            raise ValueError(f\"Expected a numpy array with a dimension (N, 3), got {arr.shape}\")\n        return Surface([Vertex.from_numpy(x) for x in arr])\n\n    @staticmethod\n    def from_Point3dVector(points: Union[openstudio.Point3dVector, List[openstudio.Point3d]]) -&gt; Surface:\n        \"\"\"Factory method to construct from an openstudio Point3dVector or a list of Point3d.\"\"\"\n        return Surface(vertices=[Vertex.from_Point3d(x) for x in points])\n\n    @staticmethod\n    def from_Surface(openstudio_surface: openstudio.model.Surface) -&gt; Surface:\n        \"\"\"Factory method to construct from an openstudio.model.Surface.\"\"\"\n        if not isinstance(openstudio_surface, openstudio.model.Surface):\n            raise ValueError(\"Expected an openstudio.model.Surface\")\n        return Surface(\n            vertices=[Vertex.from_Point3d(x) for x in openstudio_surface.vertices()],\n            name=openstudio_surface.nameString(),\n        )\n\n    @staticmethod\n    def Floor(min_x=0.0, max_x=10.0, min_y=0.0, max_y=10.0, z=0.0) -&gt; Surface:\n        \"\"\"Create a rectangular floor Surface (outward normal pointing down).\"\"\"\n        # Counterclockwise, ULC convention, except here we want to create a floor so\n        # outward normal must be pointing DOWN, so clockwise order\n        vertices_arr = np.array(\n            [\n                [max_x, max_y, z],\n                [max_x, min_y, z],\n                [min_x, min_y, z],\n                [min_x, max_y, z],\n            ]\n        )\n        vertices = [Vertex.from_numpy(x) for x in vertices_arr]\n\n        return Surface(vertices=vertices)\n\n    @staticmethod\n    def Rectangle(min_x=0.0, max_x=10.0, min_y=0.0, max_y=10.0, min_z=0.0, max_z=0.0) -&gt; Surface:\n        \"\"\"Factory method to easily create a rectangular Surface, with ULC convention.\"\"\"\n        if abs(max_z - min_z) &lt; 0.01:\n            z = min_z\n            if abs(z) &lt; 0.01:\n                print(\n                    \"Looks like you're trying to create a Floor surface... \"\n                    \"use the Surface.Floor factory method if that's the case so outwardNormal points down.\"\n                )\n\n            vertices_arr = np.array(\n                [\n                    [min_x, max_y, z],  # Upper Left Corner\n                    [min_x, min_y, z],  # Lower Left Corner\n                    [max_x, min_y, z],  # Lower Right Corner\n                    [max_x, max_y, z],  # Upper Right Corner\n                ]\n            )\n        elif abs(max_x - min_x) &lt; 0.01:\n            x = min_x\n            vertices_arr = np.array(\n                [\n                    [x, min_y, max_z],  # Upper Left Corner\n                    [x, min_y, min_z],  # Lower Left Corner\n                    [x, max_y, min_z],  # Lower Right Corner\n                    [x, max_y, max_z],  # Upper Right Corner\n                ]\n            )\n\n        elif abs(max_y - max_y) &lt; 0.01:\n            y = min_y\n            vertices_arr = np.array(\n                [\n                    [min_x, y, max_z],  # Upper Left Corner\n                    [min_x, y, min_z],  # Lower Left Corner\n                    [max_x, y, min_z],  # Lower Right Corne\n                    [max_x, y, max_z],  # Upper Right Corner\n                ]\n            )\n        else:\n            print(\"We expected at least one of x, y, z to be fixed, results are not guaranteed to work\")\n            vertices_arr = np.array(\n                [\n                    [min_x, min_y, max_z],\n                    [min_x, max_y, min_z],\n                    [max_x, max_y, min_z],\n                    [max_x, min_y, max_z],\n                ]\n            )\n\n        vertices = [Vertex.from_numpy(x) for x in vertices_arr]\n\n        return Surface(vertices=vertices)\n\n    def __init__(self, vertices, name=None):\n        \"\"\"Surface constructor.\"\"\"\n        if not isinstance(vertices, np.ndarray) and not isinstance(vertices, list):\n            raise ValueError(\"Expected a list or numpy array of Vertex\")\n\n        for i, vertex in enumerate(vertices):\n            if not isinstance(vertex, Vertex):\n                raise ValueError(f\"Element {i} is not a Vertex object\")\n\n        self.name = name\n        self.os_plane = None\n\n        self.vertices = copy.deepcopy(vertices)\n        for vertex in self.vertices:\n            vertex.surface = self\n\n    def get_plane(self) -&gt; Plane:\n        \"\"\"Returns the Plane of the Surface.\"\"\"\n        if self.os_plane is not None:\n            return self.os_plane\n        plane = openstudio.Plane(self.to_Point3dVector())\n        self.os_plane = Plane(plane.a(), plane.b(), plane.c(), plane.d())\n        return self.os_plane\n\n    def get_plot_axis(self) -&gt; str:\n        \"\"\"Returns a string representation of the plane it is on.\n\n        TODO: raises if not exactly on 'xy', 'xz' or 'yz'\n        \"\"\"\n        plane = self.get_plane()\n        tol = 0.001\n        if abs(abs(plane.a) - 1) &lt; tol:\n            return 'yz'\n        if abs(abs(plane.b) - 1) &lt; tol:\n            return 'xz'\n        if abs(abs(plane.c) - 1) &lt; tol:\n            return 'xy'\n\n        # TODO\n        raise NotImplementedError(\"Surface is not on a standard plane!\")\n\n    def plane(self) -&gt; Plane:\n        \"\"\"Compute the plane from outwardNormal and the first point, not using OpenStudio.\"\"\"\n        normalVector = self.outwardNormal()\n        if not np.isclose(normalVector.length(), 1.0):\n            raise ValueError(\"Normal Unit Vector doesn't appear to be a unit vector\")\n        self.vertices[0]\n\n        # d = -normalVector.x() * point.x() - normalVector.y() * point.y() - normalVector.z() * point.z();\n        d = (-normalVector).dot(self.vertices[0])\n\n        p = Plane(normalVector.x, normalVector.y, normalVector.z, d)\n        for i, v in enumerate(self.vertices):\n            if not p.pointOnPlane(v):\n                print(f\"Vertex {i} is not on the plane\")\n        return p\n\n    def area(self) -&gt; float:\n        \"\"\"Compute area of the surface.\"\"\"\n        newellVector = getNewellVector(self.vertices)\n        return newellVector.length() / 2.0\n\n    def outwardNormal(self) -&gt; Vertex:\n        \"\"\"Returns the outward normal (normal unit vector).\"\"\"\n        return getOutwardNormal(self.vertices)\n\n    def tilt(self) -&gt; float:\n        \"\"\"Returns the tilt of the surface, in radians, that is the angle between the outwardNormal and the Z axis.\"\"\"\n        z = Vertex(0.0, 0.0, 1.0)\n        return getAngle(self.outwardNormal(), z)\n\n    def azimuth(self) -&gt; float:\n        \"\"\"Returns the azimuth of the surface, in radians.\n\n        That is the angle between the outwardNormal and the North axis (Y-axis).\n        \"\"\"\n        normal = self.outwardNormal()\n        north = Vertex(0.0, 1.0, 0.0)\n        angle = getAngle(normal, north)\n        if normal.x &lt; 0:\n            return -angle + 2.0 * np.pi\n        return angle\n\n    def os_area(self) -&gt; Vertex:\n        \"\"\"Returns area of the surface via openstudio.\"\"\"\n        return openstudio.getArea(self.to_Point3dVector()).get()\n\n    def perimeter(self) -&gt; float:\n        \"\"\"Returns the perimeter of the surface.\"\"\"\n        return sum([edge.length() for edge in self.to_Surface3dEdges()])\n\n    def rough_centroid(self) -&gt; Vertex:\n        \"\"\"Returns the centroid calculated in a rough way: the mean of the coordinates.\"\"\"\n        return Vertex.from_numpy(np.array([x.to_numpy() for x in self.vertices]).mean(axis=0))\n\n    def os_centroid(self) -&gt; Vertex:\n        \"\"\"Returns the centroid via openstudio.\"\"\"\n        centroid_ = openstudio.getCentroid(self.to_Point3dVector())\n        if not centroid_.is_initialized():\n            raise ValueError(\"OpenStudio failed to calculate centroid\")\n        return Vertex.from_Point3d(centroid_.get())\n\n    def to_Point3dVector(self) -&gt; List[openstudio.Point3d]:\n        \"\"\"Converts vertices to a list openstudio.Point3d.\"\"\"\n        return [v.to_Point3d() for v in self.vertices]\n\n    def to_OSSurface(self, model: openstudio.model.Model) -&gt; openstudio.model.Surface:\n        \"\"\"Creates an openstudio.model.Surface in the model passed as argument.\"\"\"\n        return openstudio.model.Surface(self.to_Point3dVector(), model)\n\n    def to_numpy(self) -&gt; np.ndarray:\n        \"\"\"Get a numpy array representing the vertices.\"\"\"\n        return np.array([v.to_numpy() for v in self.vertices])\n\n    def to_Surface3dEdges(self) -&gt; List[Surface3dEge]:\n        \"\"\"Converts vertex pairs to Surface3dEge.\"\"\"\n        edges = []\n        for i, curVertex in enumerate(self.vertices):\n            if i == len(self.vertices) - 1:\n                nextVertex = self.vertices[0]\n            else:\n                nextVertex = self.vertices[i + 1]\n            edges.append(Surface3dEge(start=curVertex, end=nextVertex, firstSurface=self))\n        return edges\n\n    def split_into_n_segments(self, n_segments, axis=None, plot=False) -&gt; List[Surface]:\n        \"\"\"Splits a surface in N equal segments.\n\n        If axis is not passed, it defaults to the first one of the plane\n        eg: for a plane 'xy' it splits on 'x'\n        \"\"\"\n        plot_axis = self.get_plot_axis()\n        if axis is None:\n            axis = plot_axis[0]\n        if axis not in plot_axis:\n            raise ValueError(f\"This surface's plane is '{plot_axis}', so can't split on {axis=}\")\n\n        if n_segments &lt; 2:\n            raise ValueError(\"At least 2 segments needed\")\n\n        axis_to_index = {'x': 0, 'y': 1, 'z': 2}\n        idx = axis_to_index[axis]\n        v_np = self.to_numpy()\n        minimum = v_np[:, idx].min()\n        maximum = v_np[:, idx].max()\n        segment_length = (maximum - minimum) / n_segments\n        is_max = v_np[:, idx] == maximum\n        is_min = ~is_max\n\n        cur_min = minimum\n        cur_max = cur_min + segment_length\n\n        new_surfaces = []\n\n        for i in range(n_segments):\n            # print(cur_min, cur_max)\n            v_np_i = v_np.copy()\n            v_np_i[is_min, idx] = cur_min\n            v_np_i[is_max, idx] = cur_max\n            new_surface = Surface.from_numpy_array(v_np_i)\n            if self.name:\n                new_surface.name = f'{self.name}-{i+1}'\n            new_surfaces.append(new_surface)\n\n            cur_min = cur_max\n            cur_max += segment_length\n\n        if plot:\n            fig, ax = plt.subplots(figsize=(16, 9))\n            for new_surface in new_surfaces:\n                new_surface.plot(ax=ax)\n\n        return new_surfaces\n\n    def rotate(self, degrees: float, axis=None) -&gt; Surface:\n        \"\"\"Rotates a surface by an amount of degrees.\n\n        Args:\n        -----\n        * degrees (float): the angle to rotate it by, in degrees. Positive means clockwise\n        * axis (Vertex): if none, uses the Z axis\n\n        Returns:\n        ---------\n        * a new Surface object with rotated vertices\n        \"\"\"\n        if axis is None:\n            axis = Vertex(0.0, 0.0, 1.0)\n\n        # Lazy load to avoid circular import\n        from geomeffibem.transformation import Transformation\n\n        return Transformation.Rotation(axis=axis, radians=-openstudio.degToRad(degrees)) * self\n\n    def translate(self, translation: Vertex) -&gt; Surface:\n        \"\"\"Translates a surface along a translation vector.\"\"\"\n        from geomeffibem.transformation import Transformation\n\n        return Transformation.Translation(translation=translation) * self\n\n    def plot(self, name: Union[bool, str] = True, **kwargs):\n        \"\"\"Calls plot_vertices, cf help(plot_vertices).\"\"\"\n        if isinstance(name, str):\n            name = name\n        elif name:\n            name = self.name\n        return plot_vertices(surface_like=self, name=name, **kwargs)\n\n    def __repr__(self):\n        \"\"\"Repr.\"\"\"\n        s = \"\"\n        if self.name is not None:\n            s += f\"Surface '{self.name}' = \"\n        s += \"[\"\n        if self.name is not None:\n            s += \"\\n \"\n        imax = len(self.vertices) - 1\n        for i, v in enumerate(self.vertices):\n            if i &gt; 0:\n                s += \" \"\n            s += f\"{v}\"\n            if i &lt; imax:\n                s += \",\\n\"\n        s += \"]\"\n        return s\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.Floor","title":"<code>Floor(min_x=0.0, max_x=10.0, min_y=0.0, max_y=10.0, z=0.0)</code>  <code>staticmethod</code>","text":"<p>Create a rectangular floor Surface (outward normal pointing down).</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>@staticmethod\ndef Floor(min_x=0.0, max_x=10.0, min_y=0.0, max_y=10.0, z=0.0) -&gt; Surface:\n    \"\"\"Create a rectangular floor Surface (outward normal pointing down).\"\"\"\n    # Counterclockwise, ULC convention, except here we want to create a floor so\n    # outward normal must be pointing DOWN, so clockwise order\n    vertices_arr = np.array(\n        [\n            [max_x, max_y, z],\n            [max_x, min_y, z],\n            [min_x, min_y, z],\n            [min_x, max_y, z],\n        ]\n    )\n    vertices = [Vertex.from_numpy(x) for x in vertices_arr]\n\n    return Surface(vertices=vertices)\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.Rectangle","title":"<code>Rectangle(min_x=0.0, max_x=10.0, min_y=0.0, max_y=10.0, min_z=0.0, max_z=0.0)</code>  <code>staticmethod</code>","text":"<p>Factory method to easily create a rectangular Surface, with ULC convention.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>@staticmethod\ndef Rectangle(min_x=0.0, max_x=10.0, min_y=0.0, max_y=10.0, min_z=0.0, max_z=0.0) -&gt; Surface:\n    \"\"\"Factory method to easily create a rectangular Surface, with ULC convention.\"\"\"\n    if abs(max_z - min_z) &lt; 0.01:\n        z = min_z\n        if abs(z) &lt; 0.01:\n            print(\n                \"Looks like you're trying to create a Floor surface... \"\n                \"use the Surface.Floor factory method if that's the case so outwardNormal points down.\"\n            )\n\n        vertices_arr = np.array(\n            [\n                [min_x, max_y, z],  # Upper Left Corner\n                [min_x, min_y, z],  # Lower Left Corner\n                [max_x, min_y, z],  # Lower Right Corner\n                [max_x, max_y, z],  # Upper Right Corner\n            ]\n        )\n    elif abs(max_x - min_x) &lt; 0.01:\n        x = min_x\n        vertices_arr = np.array(\n            [\n                [x, min_y, max_z],  # Upper Left Corner\n                [x, min_y, min_z],  # Lower Left Corner\n                [x, max_y, min_z],  # Lower Right Corner\n                [x, max_y, max_z],  # Upper Right Corner\n            ]\n        )\n\n    elif abs(max_y - max_y) &lt; 0.01:\n        y = min_y\n        vertices_arr = np.array(\n            [\n                [min_x, y, max_z],  # Upper Left Corner\n                [min_x, y, min_z],  # Lower Left Corner\n                [max_x, y, min_z],  # Lower Right Corne\n                [max_x, y, max_z],  # Upper Right Corner\n            ]\n        )\n    else:\n        print(\"We expected at least one of x, y, z to be fixed, results are not guaranteed to work\")\n        vertices_arr = np.array(\n            [\n                [min_x, min_y, max_z],\n                [min_x, max_y, min_z],\n                [max_x, max_y, min_z],\n                [max_x, min_y, max_z],\n            ]\n        )\n\n    vertices = [Vertex.from_numpy(x) for x in vertices_arr]\n\n    return Surface(vertices=vertices)\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.__init__","title":"<code>__init__(vertices, name=None)</code>","text":"<p>Surface constructor.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def __init__(self, vertices, name=None):\n    \"\"\"Surface constructor.\"\"\"\n    if not isinstance(vertices, np.ndarray) and not isinstance(vertices, list):\n        raise ValueError(\"Expected a list or numpy array of Vertex\")\n\n    for i, vertex in enumerate(vertices):\n        if not isinstance(vertex, Vertex):\n            raise ValueError(f\"Element {i} is not a Vertex object\")\n\n    self.name = name\n    self.os_plane = None\n\n    self.vertices = copy.deepcopy(vertices)\n    for vertex in self.vertices:\n        vertex.surface = self\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.__repr__","title":"<code>__repr__()</code>","text":"<p>Repr.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def __repr__(self):\n    \"\"\"Repr.\"\"\"\n    s = \"\"\n    if self.name is not None:\n        s += f\"Surface '{self.name}' = \"\n    s += \"[\"\n    if self.name is not None:\n        s += \"\\n \"\n    imax = len(self.vertices) - 1\n    for i, v in enumerate(self.vertices):\n        if i &gt; 0:\n            s += \" \"\n        s += f\"{v}\"\n        if i &lt; imax:\n            s += \",\\n\"\n    s += \"]\"\n    return s\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.area","title":"<code>area()</code>","text":"<p>Compute area of the surface.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def area(self) -&gt; float:\n    \"\"\"Compute area of the surface.\"\"\"\n    newellVector = getNewellVector(self.vertices)\n    return newellVector.length() / 2.0\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.azimuth","title":"<code>azimuth()</code>","text":"<p>Returns the azimuth of the surface, in radians.</p> <p>That is the angle between the outwardNormal and the North axis (Y-axis).</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def azimuth(self) -&gt; float:\n    \"\"\"Returns the azimuth of the surface, in radians.\n\n    That is the angle between the outwardNormal and the North axis (Y-axis).\n    \"\"\"\n    normal = self.outwardNormal()\n    north = Vertex(0.0, 1.0, 0.0)\n    angle = getAngle(normal, north)\n    if normal.x &lt; 0:\n        return -angle + 2.0 * np.pi\n    return angle\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.from_Point3dVector","title":"<code>from_Point3dVector(points)</code>  <code>staticmethod</code>","text":"<p>Factory method to construct from an openstudio Point3dVector or a list of Point3d.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>@staticmethod\ndef from_Point3dVector(points: Union[openstudio.Point3dVector, List[openstudio.Point3d]]) -&gt; Surface:\n    \"\"\"Factory method to construct from an openstudio Point3dVector or a list of Point3d.\"\"\"\n    return Surface(vertices=[Vertex.from_Point3d(x) for x in points])\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.from_Surface","title":"<code>from_Surface(openstudio_surface)</code>  <code>staticmethod</code>","text":"<p>Factory method to construct from an openstudio.model.Surface.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>@staticmethod\ndef from_Surface(openstudio_surface: openstudio.model.Surface) -&gt; Surface:\n    \"\"\"Factory method to construct from an openstudio.model.Surface.\"\"\"\n    if not isinstance(openstudio_surface, openstudio.model.Surface):\n        raise ValueError(\"Expected an openstudio.model.Surface\")\n    return Surface(\n        vertices=[Vertex.from_Point3d(x) for x in openstudio_surface.vertices()],\n        name=openstudio_surface.nameString(),\n    )\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.from_numpy_array","title":"<code>from_numpy_array(arr)</code>  <code>staticmethod</code>","text":"<p>Factory method to construct from a numpy array of 3-coordinates arrays.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>@staticmethod\ndef from_numpy_array(arr) -&gt; Surface:\n    \"\"\"Factory method to construct from a numpy array of 3-coordinates arrays.\"\"\"\n    if isinstance(arr, list):\n        arr = np.array(arr)\n    if arr.shape[0] &lt; 3:\n        raise ValueError(\"Need at least 3 vertices to construct a Surface\")\n    if arr.shape[1] != 3:\n        raise ValueError(f\"Expected a numpy array with a dimension (N, 3), got {arr.shape}\")\n    return Surface([Vertex.from_numpy(x) for x in arr])\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.get_plane","title":"<code>get_plane()</code>","text":"<p>Returns the Plane of the Surface.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def get_plane(self) -&gt; Plane:\n    \"\"\"Returns the Plane of the Surface.\"\"\"\n    if self.os_plane is not None:\n        return self.os_plane\n    plane = openstudio.Plane(self.to_Point3dVector())\n    self.os_plane = Plane(plane.a(), plane.b(), plane.c(), plane.d())\n    return self.os_plane\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.get_plot_axis","title":"<code>get_plot_axis()</code>","text":"<p>Returns a string representation of the plane it is on.</p> <p>TODO: raises if not exactly on 'xy', 'xz' or 'yz'</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def get_plot_axis(self) -&gt; str:\n    \"\"\"Returns a string representation of the plane it is on.\n\n    TODO: raises if not exactly on 'xy', 'xz' or 'yz'\n    \"\"\"\n    plane = self.get_plane()\n    tol = 0.001\n    if abs(abs(plane.a) - 1) &lt; tol:\n        return 'yz'\n    if abs(abs(plane.b) - 1) &lt; tol:\n        return 'xz'\n    if abs(abs(plane.c) - 1) &lt; tol:\n        return 'xy'\n\n    # TODO\n    raise NotImplementedError(\"Surface is not on a standard plane!\")\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.os_area","title":"<code>os_area()</code>","text":"<p>Returns area of the surface via openstudio.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def os_area(self) -&gt; Vertex:\n    \"\"\"Returns area of the surface via openstudio.\"\"\"\n    return openstudio.getArea(self.to_Point3dVector()).get()\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.os_centroid","title":"<code>os_centroid()</code>","text":"<p>Returns the centroid via openstudio.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def os_centroid(self) -&gt; Vertex:\n    \"\"\"Returns the centroid via openstudio.\"\"\"\n    centroid_ = openstudio.getCentroid(self.to_Point3dVector())\n    if not centroid_.is_initialized():\n        raise ValueError(\"OpenStudio failed to calculate centroid\")\n    return Vertex.from_Point3d(centroid_.get())\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.outwardNormal","title":"<code>outwardNormal()</code>","text":"<p>Returns the outward normal (normal unit vector).</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def outwardNormal(self) -&gt; Vertex:\n    \"\"\"Returns the outward normal (normal unit vector).\"\"\"\n    return getOutwardNormal(self.vertices)\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.perimeter","title":"<code>perimeter()</code>","text":"<p>Returns the perimeter of the surface.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def perimeter(self) -&gt; float:\n    \"\"\"Returns the perimeter of the surface.\"\"\"\n    return sum([edge.length() for edge in self.to_Surface3dEdges()])\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.plane","title":"<code>plane()</code>","text":"<p>Compute the plane from outwardNormal and the first point, not using OpenStudio.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def plane(self) -&gt; Plane:\n    \"\"\"Compute the plane from outwardNormal and the first point, not using OpenStudio.\"\"\"\n    normalVector = self.outwardNormal()\n    if not np.isclose(normalVector.length(), 1.0):\n        raise ValueError(\"Normal Unit Vector doesn't appear to be a unit vector\")\n    self.vertices[0]\n\n    # d = -normalVector.x() * point.x() - normalVector.y() * point.y() - normalVector.z() * point.z();\n    d = (-normalVector).dot(self.vertices[0])\n\n    p = Plane(normalVector.x, normalVector.y, normalVector.z, d)\n    for i, v in enumerate(self.vertices):\n        if not p.pointOnPlane(v):\n            print(f\"Vertex {i} is not on the plane\")\n    return p\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.plot","title":"<code>plot(name=True, **kwargs)</code>","text":"<p>Calls plot_vertices, cf help(plot_vertices).</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def plot(self, name: Union[bool, str] = True, **kwargs):\n    \"\"\"Calls plot_vertices, cf help(plot_vertices).\"\"\"\n    if isinstance(name, str):\n        name = name\n    elif name:\n        name = self.name\n    return plot_vertices(surface_like=self, name=name, **kwargs)\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.rotate","title":"<code>rotate(degrees, axis=None)</code>","text":"<p>Rotates a surface by an amount of degrees.</p>"},{"location":"api/#geomeffibem.surface.Surface.rotate--args","title":"Args:","text":"<ul> <li>degrees (float): the angle to rotate it by, in degrees. Positive means clockwise</li> <li>axis (Vertex): if none, uses the Z axis</li> </ul>"},{"location":"api/#geomeffibem.surface.Surface.rotate--returns","title":"Returns:","text":"<ul> <li>a new Surface object with rotated vertices</li> </ul> Source code in <code>geomeffibem/surface.py</code> <pre><code>def rotate(self, degrees: float, axis=None) -&gt; Surface:\n    \"\"\"Rotates a surface by an amount of degrees.\n\n    Args:\n    -----\n    * degrees (float): the angle to rotate it by, in degrees. Positive means clockwise\n    * axis (Vertex): if none, uses the Z axis\n\n    Returns:\n    ---------\n    * a new Surface object with rotated vertices\n    \"\"\"\n    if axis is None:\n        axis = Vertex(0.0, 0.0, 1.0)\n\n    # Lazy load to avoid circular import\n    from geomeffibem.transformation import Transformation\n\n    return Transformation.Rotation(axis=axis, radians=-openstudio.degToRad(degrees)) * self\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.rough_centroid","title":"<code>rough_centroid()</code>","text":"<p>Returns the centroid calculated in a rough way: the mean of the coordinates.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def rough_centroid(self) -&gt; Vertex:\n    \"\"\"Returns the centroid calculated in a rough way: the mean of the coordinates.\"\"\"\n    return Vertex.from_numpy(np.array([x.to_numpy() for x in self.vertices]).mean(axis=0))\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.split_into_n_segments","title":"<code>split_into_n_segments(n_segments, axis=None, plot=False)</code>","text":"<p>Splits a surface in N equal segments.</p> <p>If axis is not passed, it defaults to the first one of the plane eg: for a plane 'xy' it splits on 'x'</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def split_into_n_segments(self, n_segments, axis=None, plot=False) -&gt; List[Surface]:\n    \"\"\"Splits a surface in N equal segments.\n\n    If axis is not passed, it defaults to the first one of the plane\n    eg: for a plane 'xy' it splits on 'x'\n    \"\"\"\n    plot_axis = self.get_plot_axis()\n    if axis is None:\n        axis = plot_axis[0]\n    if axis not in plot_axis:\n        raise ValueError(f\"This surface's plane is '{plot_axis}', so can't split on {axis=}\")\n\n    if n_segments &lt; 2:\n        raise ValueError(\"At least 2 segments needed\")\n\n    axis_to_index = {'x': 0, 'y': 1, 'z': 2}\n    idx = axis_to_index[axis]\n    v_np = self.to_numpy()\n    minimum = v_np[:, idx].min()\n    maximum = v_np[:, idx].max()\n    segment_length = (maximum - minimum) / n_segments\n    is_max = v_np[:, idx] == maximum\n    is_min = ~is_max\n\n    cur_min = minimum\n    cur_max = cur_min + segment_length\n\n    new_surfaces = []\n\n    for i in range(n_segments):\n        # print(cur_min, cur_max)\n        v_np_i = v_np.copy()\n        v_np_i[is_min, idx] = cur_min\n        v_np_i[is_max, idx] = cur_max\n        new_surface = Surface.from_numpy_array(v_np_i)\n        if self.name:\n            new_surface.name = f'{self.name}-{i+1}'\n        new_surfaces.append(new_surface)\n\n        cur_min = cur_max\n        cur_max += segment_length\n\n    if plot:\n        fig, ax = plt.subplots(figsize=(16, 9))\n        for new_surface in new_surfaces:\n            new_surface.plot(ax=ax)\n\n    return new_surfaces\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.tilt","title":"<code>tilt()</code>","text":"<p>Returns the tilt of the surface, in radians, that is the angle between the outwardNormal and the Z axis.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def tilt(self) -&gt; float:\n    \"\"\"Returns the tilt of the surface, in radians, that is the angle between the outwardNormal and the Z axis.\"\"\"\n    z = Vertex(0.0, 0.0, 1.0)\n    return getAngle(self.outwardNormal(), z)\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.to_OSSurface","title":"<code>to_OSSurface(model)</code>","text":"<p>Creates an openstudio.model.Surface in the model passed as argument.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def to_OSSurface(self, model: openstudio.model.Model) -&gt; openstudio.model.Surface:\n    \"\"\"Creates an openstudio.model.Surface in the model passed as argument.\"\"\"\n    return openstudio.model.Surface(self.to_Point3dVector(), model)\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.to_Point3dVector","title":"<code>to_Point3dVector()</code>","text":"<p>Converts vertices to a list openstudio.Point3d.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def to_Point3dVector(self) -&gt; List[openstudio.Point3d]:\n    \"\"\"Converts vertices to a list openstudio.Point3d.\"\"\"\n    return [v.to_Point3d() for v in self.vertices]\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.to_Surface3dEdges","title":"<code>to_Surface3dEdges()</code>","text":"<p>Converts vertex pairs to Surface3dEge.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def to_Surface3dEdges(self) -&gt; List[Surface3dEge]:\n    \"\"\"Converts vertex pairs to Surface3dEge.\"\"\"\n    edges = []\n    for i, curVertex in enumerate(self.vertices):\n        if i == len(self.vertices) - 1:\n            nextVertex = self.vertices[0]\n        else:\n            nextVertex = self.vertices[i + 1]\n        edges.append(Surface3dEge(start=curVertex, end=nextVertex, firstSurface=self))\n    return edges\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.to_numpy","title":"<code>to_numpy()</code>","text":"<p>Get a numpy array representing the vertices.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def to_numpy(self) -&gt; np.ndarray:\n    \"\"\"Get a numpy array representing the vertices.\"\"\"\n    return np.array([v.to_numpy() for v in self.vertices])\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface.translate","title":"<code>translate(translation)</code>","text":"<p>Translates a surface along a translation vector.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def translate(self, translation: Vertex) -&gt; Surface:\n    \"\"\"Translates a surface along a translation vector.\"\"\"\n    from geomeffibem.transformation import Transformation\n\n    return Transformation.Translation(translation=translation) * self\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface3dEge","title":"<code>Surface3dEge</code>","text":"<p>An Edge has a start and an end Vertex, and a list of surfaces it was found on.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>class Surface3dEge:\n    \"\"\"An Edge has a start and an end Vertex, and a list of surfaces it was found on.\"\"\"\n\n    def __init__(self, start: Vertex, end: Vertex, firstSurface: Surface):\n        \"\"\"Constructor.\"\"\"\n        self.start = start\n        self.end = end\n        self.allSurfaces = [firstSurface]\n\n    def containsPoints(self, testVertex: Vertex) -&gt; bool:\n        \"\"\"Checks whether a Point is on the edge.\n\n        It is not almost equal to the start and end points, and,\n        isPointOnLineBetweenPoints(start, end, testVertex) is true.\n        \"\"\"\n        return (\n            not isAlmostEqual3dPt(self.start, testVertex)\n            and not isAlmostEqual3dPt(self.end, testVertex)\n            and isPointOnLineBetweenPoints(self.start, self.end, testVertex)\n        )\n\n    def length(self) -&gt; float:\n        \"\"\"Compute distance from start to end.\"\"\"\n        return distance(self.start, self.end)\n\n    def count(self) -&gt; int:\n        \"\"\"Number of Surfaces it was found on.\"\"\"\n        return len(self.allSurfaces)\n\n    def __eq__(self, other):\n        \"\"\"Operator equal.\"\"\"\n        if not isinstance(other, Surface3dEge):\n            raise NotImplementedError(\"Not implemented for any other types than Surface3dEge itself\")\n\n        return (isAlmostEqual3dPt(self.start, other.start) and isAlmostEqual3dPt(self.end, other.end)) or (\n            isAlmostEqual3dPt(self.start, other.end) and isAlmostEqual3dPt(self.end, other.start)\n        )\n\n    def __ne__(self, other):\n        \"\"\"Operator not equal.\"\"\"\n        return not self == other\n\n    def __repr__(self):\n        \"\"\"Repr.\"\"\"\n        return f\"start={self.start}, end={self.end}, count={self.count()}, firstSurface={self.allSurfaces[0].name}\"\n\n    def plot_on_first_surface(self, ax=None):\n        \"\"\"Plots this segment in red atop the outline of the Surface it came from.\"\"\"\n        surface = self.allSurfaces[0]\n\n        if ax is None:\n            fig, ax = plt.subplots(figsize=(16, 9))\n        surface.plot(ax=ax)\n        plot_vertices([self.start, self.end], plane=surface.get_plot_axis(), c='r', ax=ax, annotate=False)\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface3dEge.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Operator equal.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Operator equal.\"\"\"\n    if not isinstance(other, Surface3dEge):\n        raise NotImplementedError(\"Not implemented for any other types than Surface3dEge itself\")\n\n    return (isAlmostEqual3dPt(self.start, other.start) and isAlmostEqual3dPt(self.end, other.end)) or (\n        isAlmostEqual3dPt(self.start, other.end) and isAlmostEqual3dPt(self.end, other.start)\n    )\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface3dEge.__init__","title":"<code>__init__(start, end, firstSurface)</code>","text":"<p>Constructor.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def __init__(self, start: Vertex, end: Vertex, firstSurface: Surface):\n    \"\"\"Constructor.\"\"\"\n    self.start = start\n    self.end = end\n    self.allSurfaces = [firstSurface]\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface3dEge.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Operator not equal.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def __ne__(self, other):\n    \"\"\"Operator not equal.\"\"\"\n    return not self == other\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface3dEge.__repr__","title":"<code>__repr__()</code>","text":"<p>Repr.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def __repr__(self):\n    \"\"\"Repr.\"\"\"\n    return f\"start={self.start}, end={self.end}, count={self.count()}, firstSurface={self.allSurfaces[0].name}\"\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface3dEge.containsPoints","title":"<code>containsPoints(testVertex)</code>","text":"<p>Checks whether a Point is on the edge.</p> <p>It is not almost equal to the start and end points, and, isPointOnLineBetweenPoints(start, end, testVertex) is true.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def containsPoints(self, testVertex: Vertex) -&gt; bool:\n    \"\"\"Checks whether a Point is on the edge.\n\n    It is not almost equal to the start and end points, and,\n    isPointOnLineBetweenPoints(start, end, testVertex) is true.\n    \"\"\"\n    return (\n        not isAlmostEqual3dPt(self.start, testVertex)\n        and not isAlmostEqual3dPt(self.end, testVertex)\n        and isPointOnLineBetweenPoints(self.start, self.end, testVertex)\n    )\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface3dEge.count","title":"<code>count()</code>","text":"<p>Number of Surfaces it was found on.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def count(self) -&gt; int:\n    \"\"\"Number of Surfaces it was found on.\"\"\"\n    return len(self.allSurfaces)\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface3dEge.length","title":"<code>length()</code>","text":"<p>Compute distance from start to end.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def length(self) -&gt; float:\n    \"\"\"Compute distance from start to end.\"\"\"\n    return distance(self.start, self.end)\n</code></pre>"},{"location":"api/#geomeffibem.surface.Surface3dEge.plot_on_first_surface","title":"<code>plot_on_first_surface(ax=None)</code>","text":"<p>Plots this segment in red atop the outline of the Surface it came from.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def plot_on_first_surface(self, ax=None):\n    \"\"\"Plots this segment in red atop the outline of the Surface it came from.\"\"\"\n    surface = self.allSurfaces[0]\n\n    if ax is None:\n        fig, ax = plt.subplots(figsize=(16, 9))\n    surface.plot(ax=ax)\n    plot_vertices([self.start, self.end], plane=surface.get_plot_axis(), c='r', ax=ax, annotate=False)\n</code></pre>"},{"location":"api/#geomeffibem.surface.get_surface_from_surface_like","title":"<code>get_surface_from_surface_like(surface_like)</code>","text":"<p>Helper to get a Surface (class) from a surface like object.</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def get_surface_from_surface_like(surface_like: Union[Surface, List[Vertex], openstudio.model.Surface]) -&gt; Surface:\n    \"\"\"Helper to get a Surface (class) from a surface like object.\"\"\"\n    if isinstance(surface_like, openstudio.model.Surface):\n        surface = Surface.from_Surface(surface_like)\n    elif isinstance(surface_like, Surface):\n        surface = surface_like\n    else:\n        if isinstance(surface_like, list):\n            surface_like = np.array(surface_like)\n\n        if isinstance(surface_like[0], openstudio.Point3d):\n            surface = Surface.from_Point3dVector(surface_like)\n        elif isinstance(surface_like[0], np.ndarray):\n            surface = Surface.from_numpy_array(surface_like)\n        elif isinstance(surface_like[0], Vertex):\n            surface = Surface(surface_like)\n\n    return surface\n</code></pre>"},{"location":"api/#geomeffibem.surface.plot_vertices","title":"<code>plot_vertices(surface_like, ax=None, center_axes=False, with_rough_centroid=False, with_os_centroid=False, annotate=True, linewidth=None, force_align=False, name=None, plane=None, annotate_kwargs=dict(color='r', xytext=(5, 5), textcoords='offset points'), **kwargs)</code>","text":"<p>Plot any surface-like object in 2D.</p> <p>Accepts a Surface, a list or numpy array of Vertex, or an openstudio.model.Surface object</p> <p>TODO: Assumes the surface is planar and falls exactly on 'xy', 'xz' or 'yz' plane currently</p> Source code in <code>geomeffibem/surface.py</code> <pre><code>def plot_vertices(\n    surface_like: Union[Surface, List[Vertex], openstudio.model.Surface],\n    ax=None,\n    center_axes=False,\n    with_rough_centroid=False,\n    with_os_centroid=False,\n    annotate=True,\n    linewidth=None,\n    force_align=False,\n    name=None,\n    plane=None,\n    annotate_kwargs=dict(color='r', xytext=(5, 5), textcoords='offset points'),\n    # Passed to ax.plot/plt.plot\n    **kwargs,\n):\n    \"\"\"Plot any surface-like object in 2D.\n\n    Accepts a Surface, a list or numpy array of Vertex, or an openstudio.model.Surface object\n\n    TODO: Assumes the surface is planar and falls exactly on 'xy', 'xz' or 'yz' plane currently\n    \"\"\"\n    surface = get_surface_from_surface_like(surface_like=surface_like)\n\n    is_aligned = False\n    if plane is None and not force_align:\n        try:\n            plane = surface.get_plot_axis()\n        except NotImplementedError as e:\n            print(e)\n            force_align = True\n    if plane is None and force_align:\n        print(\"aligning Face\")\n        # Lazy load to avoid circular import\n        from geomeffibem.transformation import Transformation\n\n        faceTransformation = Transformation.alignFace(surface.vertices)\n        faceTransformationInverse = faceTransformation.inverse()\n        points = faceTransformationInverse * surface.vertices\n        surface = Surface(points, name=surface.name)\n        plane = 'xy'\n        is_aligned = True\n\n    points = surface.to_numpy()\n\n    if plane == 'xy':\n        xs = points[:, 0]\n        ys = points[:, 1]\n    elif plane == 'xz':\n        xs = points[:, 0]\n        ys = points[:, 2]\n    elif plane == 'yz':\n        xs = points[:, 1]\n        ys = points[:, 2]\n    else:\n        raise ValueError(\"plane must be in ['xy', 'xz', 'yz']\")\n    if ax is None:\n        # print(\"Making a figure\")\n        max_width = xs.max() - xs.min()\n        max_height = ys.max() - ys.min()\n        h = 6\n        w = h * max_width / max_height\n        # print(w, h)\n        fig, ax = plt.subplots(figsize=(w, h))\n\n    ax.plot(np.append(xs, xs[0]), np.append(ys, ys[0]), marker='x', markeredgecolor='r', linewidth=linewidth, **kwargs)\n    ax.set_xlabel(plane[0] if not is_aligned else \"x'\")\n    ax.set_ylabel(plane[1] if not is_aligned else \"y'\")\n    if annotate:\n        for i, (x, y) in enumerate(zip(xs, ys)):\n            ax.annotate(f\"{i+1} ({x:.2f}, {y:.2f})\", xy=(x, y), **annotate_kwargs)\n\n    if with_rough_centroid:\n        centroid_x, centroid_y = surface.rough_centroid().get_coords_on_plane(plane=plane)\n        ax.annotate(f\"rough ({centroid_x}, {centroid_y})\", xy=(centroid_x, centroid_y))\n        ax.plot(centroid_x, centroid_y, 'rx')\n    if with_os_centroid or name is not None and name is not False:\n        centroid_x, centroid_y = surface.os_centroid().get_coords_on_plane(plane=plane)\n        if with_os_centroid:\n            ax.annotate(f\"os ({centroid_x}, {centroid_y})\", xy=(centroid_x, centroid_y))\n            ax.plot(centroid_x, centroid_y, 'gx')\n            if name:\n                ax.annotate(\n                    name + (\" (aligned)\" if is_aligned else \"\"),\n                    xy=(centroid_x, centroid_y),\n                    xytext=(0, 50),\n                    textcoords='offset pixels',\n                    color='b',\n                    arrowprops=dict(edgecolor='b', lw=1, ls='-', arrowstyle='-&gt;'),\n                )\n        else:\n            ax.annotate(\n                name + (\" (aligned)\" if is_aligned else \"\"), xy=(centroid_x, centroid_y), ha='center', va='center'\n            )\n\n    ax.spines['right'].set_color('none')\n    ax.spines['top'].set_color('none')  # hide top axis\n\n    if center_axes:\n        ax.spines['bottom'].set_position('zero')  # x-axis where y=0\n        ax.spines['left'].set_position('zero')\n        ax.xaxis.set_label_position(\"top\")\n\n    return ax\n</code></pre>"},{"location":"api/#plane","title":"Plane","text":"<p>Plane.</p>"},{"location":"api/#geomeffibem.plane.Plane","title":"<code>Plane</code>","text":"<p>A 3D Plane.</p> <p>Equation is <code>ax + by + cz + d = 0</code></p> Source code in <code>geomeffibem/plane.py</code> <pre><code>class Plane:\n    \"\"\"A 3D Plane.\n\n    Equation is `ax + by + cz + d = 0`\n    \"\"\"\n\n    def __init__(self, a, b, c, d):\n        \"\"\"Plane constructor.\"\"\"\n        self.a = a\n        self.b = b\n        self.c = c\n        self.d = d\n\n    def outwardNormal(self) -&gt; np.ndarray:\n        \"\"\"The outwardNormal of the plane.\"\"\"\n        return Vertex(self.a, self.b, self.c)\n\n    def is_orthogonal(self) -&gt; bool:\n        \"\"\"Checks if the plane is orthogonal.\"\"\"\n        return np.sum(np.abs(self.outwardNormal().to_numpy())) == 1.0\n\n    def pointOnPlane(self, point: Vertex, tol=0.001) -&gt; bool:\n        \"\"\"Checks whether the Vertex is on the Plane.\"\"\"\n        # project point to plane\n        projected = self.project(point)\n\n        return distance(point, projected) &lt;= tol\n\n    def project(self, point: Vertex) -&gt; Vertex:\n        \"\"\"Project a point onto a Plane.\"\"\"\n        # http://www.9math.com/book/projection-point-plane\n        if not isinstance(point, Vertex):\n            raise ValueError(\"Expected a Vertex object\")\n        u = point.x\n        v = point.y\n        w = point.z\n\n        num = self.a * u + self.b * v + self.c * w + self.d\n        den = self.a * self.a + self.b * self.b + self.c * self.c  # this should always be 1.0\n        ratio = num / den\n\n        x = u - self.a * ratio\n        y = v - self.b * ratio\n        z = w - self.c * ratio\n\n        return Vertex(x, y, z)\n\n    def __repr__(self):\n        \"\"\"Repr.\"\"\"\n        return f\"Plane ({self.a}, {self.b}, {self.c}, {self.d})\"\n</code></pre>"},{"location":"api/#geomeffibem.plane.Plane.__init__","title":"<code>__init__(a, b, c, d)</code>","text":"<p>Plane constructor.</p> Source code in <code>geomeffibem/plane.py</code> <pre><code>def __init__(self, a, b, c, d):\n    \"\"\"Plane constructor.\"\"\"\n    self.a = a\n    self.b = b\n    self.c = c\n    self.d = d\n</code></pre>"},{"location":"api/#geomeffibem.plane.Plane.__repr__","title":"<code>__repr__()</code>","text":"<p>Repr.</p> Source code in <code>geomeffibem/plane.py</code> <pre><code>def __repr__(self):\n    \"\"\"Repr.\"\"\"\n    return f\"Plane ({self.a}, {self.b}, {self.c}, {self.d})\"\n</code></pre>"},{"location":"api/#geomeffibem.plane.Plane.is_orthogonal","title":"<code>is_orthogonal()</code>","text":"<p>Checks if the plane is orthogonal.</p> Source code in <code>geomeffibem/plane.py</code> <pre><code>def is_orthogonal(self) -&gt; bool:\n    \"\"\"Checks if the plane is orthogonal.\"\"\"\n    return np.sum(np.abs(self.outwardNormal().to_numpy())) == 1.0\n</code></pre>"},{"location":"api/#geomeffibem.plane.Plane.outwardNormal","title":"<code>outwardNormal()</code>","text":"<p>The outwardNormal of the plane.</p> Source code in <code>geomeffibem/plane.py</code> <pre><code>def outwardNormal(self) -&gt; np.ndarray:\n    \"\"\"The outwardNormal of the plane.\"\"\"\n    return Vertex(self.a, self.b, self.c)\n</code></pre>"},{"location":"api/#geomeffibem.plane.Plane.pointOnPlane","title":"<code>pointOnPlane(point, tol=0.001)</code>","text":"<p>Checks whether the Vertex is on the Plane.</p> Source code in <code>geomeffibem/plane.py</code> <pre><code>def pointOnPlane(self, point: Vertex, tol=0.001) -&gt; bool:\n    \"\"\"Checks whether the Vertex is on the Plane.\"\"\"\n    # project point to plane\n    projected = self.project(point)\n\n    return distance(point, projected) &lt;= tol\n</code></pre>"},{"location":"api/#geomeffibem.plane.Plane.project","title":"<code>project(point)</code>","text":"<p>Project a point onto a Plane.</p> Source code in <code>geomeffibem/plane.py</code> <pre><code>def project(self, point: Vertex) -&gt; Vertex:\n    \"\"\"Project a point onto a Plane.\"\"\"\n    # http://www.9math.com/book/projection-point-plane\n    if not isinstance(point, Vertex):\n        raise ValueError(\"Expected a Vertex object\")\n    u = point.x\n    v = point.y\n    w = point.z\n\n    num = self.a * u + self.b * v + self.c * w + self.d\n    den = self.a * self.a + self.b * self.b + self.c * self.c  # this should always be 1.0\n    ratio = num / den\n\n    x = u - self.a * ratio\n    y = v - self.b * ratio\n    z = w - self.c * ratio\n\n    return Vertex(x, y, z)\n</code></pre>"},{"location":"api/#polyhedron","title":"Polyhedron","text":"<p>A Polyhedron is a collection of Surface objects.</p> <p>It's meant to represent a volume. You can check whether it's enclosed or not.</p>"},{"location":"api/#geomeffibem.polyhedron.Polyhedron","title":"<code>Polyhedron</code>","text":"<p>A collection of Surfaces, meant to represent a Volume.</p> Source code in <code>geomeffibem/polyhedron.py</code> <pre><code>class Polyhedron:\n    \"\"\"A collection of Surfaces, meant to represent a Volume.\"\"\"\n\n    def __init__(self, surfaces: List[Surface]):\n        \"\"\"Constructor from a list of Surface objects.\"\"\"\n        if not isinstance(surfaces, np.ndarray) and not isinstance(surfaces, list):\n            raise ValueError(\"Expected a list or numpy array of Surfaces\")\n\n        for i, surface in enumerate(surfaces):\n            if not isinstance(surface, Surface):\n                raise ValueError(f\"Element {i} is not a Surface object\")\n        self.surfaces = surfaces\n\n    def get_surface_by_name(self, name):\n        \"\"\"Locate a surface by its name.\"\"\"\n        for s in self.surfaces:\n            if s.name is not None and s.name == name:\n                return s\n\n    def numVertices(self):\n        \"\"\"Counts the total number of vertices for all surfaces.\"\"\"\n        count = 0\n        for s in self.surfaces:\n            count += len(s.vertices)\n        return count\n\n    def uniqueVertices(self) -&gt; List[Vertex]:\n        \"\"\"Get a list of unique vertices (uses Vertex __eq__ operator which has a tolerance).\"\"\"\n        uniqueVertices: List[Vertex] = []\n        for s in self.surfaces:\n            for vertex in s.vertices:\n                found = False\n                for unique_v in uniqueVertices:\n                    if unique_v == vertex:\n                        found = True\n                        break\n                if not found:\n                    uniqueVertices.append(vertex)\n        return uniqueVertices\n\n    @staticmethod\n    def edgesNotTwoForEnclosedVolumeTest(zonePoly: Polyhedron) -&gt; Tuple[List[Surface3dEge], List[Surface3dEge]]:\n        \"\"\"Counts the number of times an Edge is used.\n\n        Returns the ones that isn't used twice (and the ones used twice for debugging/inspection)\n        \"\"\"\n        uniqueSurface3dEdges: List[Surface3dEge] = []\n\n        for surface in zonePoly.surfaces:\n            for edge in surface.to_Surface3dEdges():\n                found = False\n                for uniqEdge in uniqueSurface3dEdges:\n                    if uniqEdge == edge:\n                        uniqEdge.allSurfaces.append(surface)\n                        found = True\n                        break\n                if not found:\n                    uniqueSurface3dEdges.append(edge)\n\n        edgesNotTwoCount = [x for x in uniqueSurface3dEdges if x.count() != 2]\n        edgesTwoCount = [x for x in uniqueSurface3dEdges if x.count() == 2]\n        return edgesNotTwoCount, edgesTwoCount\n\n    def updateZonePolygonsForMissingColinearPoints(self) -&gt; Polyhedron:\n        \"\"\"Creates a new Polyhedron with extra vertices when a point is found to be on a line segment.\"\"\"\n        updZonePoly = copy.deepcopy(self)\n\n        uniqVertices = self.uniqueVertices()\n\n        for surface in updZonePoly.surfaces:\n            insertedVertex = True\n            while insertedVertex:\n                insertedVertex = False\n                for i, edge in enumerate(surface.to_Surface3dEdges()):\n                    for testVertex in uniqVertices:\n                        if edge.containsPoints(testVertex):\n                            if i == len(surface.vertices) - 1:\n                                inext = 0\n                            else:\n                                inext = i + 1\n                            surface.vertices.insert(inext, testVertex)\n                            insertedVertex = True\n                            break\n                    # Break out of the loop on vertices/edges too, start again at while loop\n                    if insertedVertex:\n                        break\n        return updZonePoly\n\n    def isEnclosedVolume(self) -&gt; Tuple[bool, List[Surface3dEge]]:\n        \"\"\"Checks if the Polyhedron is enclosed, that is all its edges are used exactly twice.\"\"\"\n        edgeNot2orig, _ = Polyhedron.edgesNotTwoForEnclosedVolumeTest(zonePoly=self)\n        if not edgeNot2orig:\n            return True, []\n\n        print(\"Updating Polyhedron with collinear vertices on lines\")\n        updatedZonePoly = self.updateZonePolygonsForMissingColinearPoints()\n        edgeNot2again, _ = Polyhedron.edgesNotTwoForEnclosedVolumeTest(updatedZonePoly)\n        if not edgeNot2again:\n            return True, []\n\n        return False, edgesInBoth(edgeNot2orig, edgeNot2again)\n\n    def calcPolyhedronVolume(self) -&gt; float:\n        \"\"\"Calculates the Volume of an ENCLOSED Polyhedron.\"\"\"\n        volume = 0.0\n        for surface in self.surfaces:\n            vertices = surface.vertices\n            p3FaceOrigin = vertices[1] - Vertex(0, 0, 0)\n            newellAreaVector = getNewellVector(vertices)\n            pyramidVolume = newellAreaVector.dot(p3FaceOrigin)\n            volume += pyramidVolume\n        # Our newellArea vector has twice the length\n        volume /= 6.0\n        return volume\n\n    def to_os_cpp_code(self):\n        \"\"\"For my own convenience when writting OpenStudio tests.\"\"\"\n        for i, sf in enumerate(self.surfaces):\n            if sf.name is not None:\n                name = sf.name\n            else:\n                name = f\"Surface {i+1}\"\n            if name[1] == '-':\n                cleaned_name = name[2:].lower().replace('-', '')\n            else:\n                cleaned_name = name.lower().replace('-', '')\n            s = \"{\"\n            if sf.name is not None:\n                s += \"\\n \"\n            n_vertices = len(sf.vertices)\n            imax = n_vertices - 1\n            for i, v in enumerate(sf.vertices):\n                if i &gt; 0:\n                    s += \" \"\n                s += f\"{{{v.x:+.1f}, {v.y:+.1f}, {v.z:+.1f}}}\"\n                if i &lt; imax:\n                    s += \",\\n\"\n            s += \"}\"\n\n            print(f'Surface {cleaned_name}({s}, m);')\n            print(f'{cleaned_name}.setName(\"{name}\");')\n            print(f'{cleaned_name}.setSpace(s);\\n')\n\n    def to_eplus_cpp_code(self):\n        \"\"\"For my own convenience when writting EnergyPlus tests.\"\"\"\n        n_surfaces = len(self.surfaces)\n        print(\n            f\"\"\"\n            Array1D_bool enteredCeilingHeight;\n            state-&gt;dataGlobal-&gt;NumOfZones = 1;\n            enteredCeilingHeight.dimension(state-&gt;dataGlobal-&gt;NumOfZones, false);\n            state-&gt;dataHeatBal-&gt;Zone.allocate(state-&gt;dataGlobal-&gt;NumOfZones);\n            state-&gt;dataHeatBal-&gt;Zone(1).HasFloor = true;\n            state-&gt;dataHeatBal-&gt;Zone(1).HTSurfaceFirst = 1;\n            state-&gt;dataHeatBal-&gt;Zone(1).AllSurfaceFirst = 1;\n            state-&gt;dataHeatBal-&gt;Zone(1).AllSurfaceLast = {n_surfaces};\n\n            state-&gt;dataSurface-&gt;Surface.allocate({n_surfaces});\n            \"\"\"\n        )\n        for i, sf in enumerate(self.surfaces):\n            n_vertices = len(sf.vertices)\n            name = sf.name\n            if 'ROOF' in name:\n                tilt = 0.0\n                c = 'SurfaceClass::Roof'\n            elif 'FLOOR' in name:\n                tilt = 180.0\n                c = 'SurfaceClass::Floor'\n            else:\n                tilt = 90.0\n                c = 'SurfaceClass::Wall'\n\n            print(\n                f'''\n            state-&gt;dataSurface-&gt;Surface({i+1}).Name = \"{name}\";\n            state-&gt;dataSurface-&gt;Surface({i+1}).Sides = {n_vertices};\n            state-&gt;dataSurface-&gt;Surface({i+1}).Vertex.dimension({n_vertices});\n            state-&gt;dataSurface-&gt;Surface({i+1}).Class = {c};\n            state-&gt;dataSurface-&gt;Surface({i+1}).Tilt = {tilt};'''\n            )\n\n            for j, v in enumerate(sf.vertices):\n                print(f\"    state-&gt;dataSurface-&gt;Surface({i+1}).Vertex(1) = Vector({v.x}, {v.y}, {v.z});\")\n</code></pre>"},{"location":"api/#geomeffibem.polyhedron.Polyhedron.__init__","title":"<code>__init__(surfaces)</code>","text":"<p>Constructor from a list of Surface objects.</p> Source code in <code>geomeffibem/polyhedron.py</code> <pre><code>def __init__(self, surfaces: List[Surface]):\n    \"\"\"Constructor from a list of Surface objects.\"\"\"\n    if not isinstance(surfaces, np.ndarray) and not isinstance(surfaces, list):\n        raise ValueError(\"Expected a list or numpy array of Surfaces\")\n\n    for i, surface in enumerate(surfaces):\n        if not isinstance(surface, Surface):\n            raise ValueError(f\"Element {i} is not a Surface object\")\n    self.surfaces = surfaces\n</code></pre>"},{"location":"api/#geomeffibem.polyhedron.Polyhedron.calcPolyhedronVolume","title":"<code>calcPolyhedronVolume()</code>","text":"<p>Calculates the Volume of an ENCLOSED Polyhedron.</p> Source code in <code>geomeffibem/polyhedron.py</code> <pre><code>def calcPolyhedronVolume(self) -&gt; float:\n    \"\"\"Calculates the Volume of an ENCLOSED Polyhedron.\"\"\"\n    volume = 0.0\n    for surface in self.surfaces:\n        vertices = surface.vertices\n        p3FaceOrigin = vertices[1] - Vertex(0, 0, 0)\n        newellAreaVector = getNewellVector(vertices)\n        pyramidVolume = newellAreaVector.dot(p3FaceOrigin)\n        volume += pyramidVolume\n    # Our newellArea vector has twice the length\n    volume /= 6.0\n    return volume\n</code></pre>"},{"location":"api/#geomeffibem.polyhedron.Polyhedron.edgesNotTwoForEnclosedVolumeTest","title":"<code>edgesNotTwoForEnclosedVolumeTest(zonePoly)</code>  <code>staticmethod</code>","text":"<p>Counts the number of times an Edge is used.</p> <p>Returns the ones that isn't used twice (and the ones used twice for debugging/inspection)</p> Source code in <code>geomeffibem/polyhedron.py</code> <pre><code>@staticmethod\ndef edgesNotTwoForEnclosedVolumeTest(zonePoly: Polyhedron) -&gt; Tuple[List[Surface3dEge], List[Surface3dEge]]:\n    \"\"\"Counts the number of times an Edge is used.\n\n    Returns the ones that isn't used twice (and the ones used twice for debugging/inspection)\n    \"\"\"\n    uniqueSurface3dEdges: List[Surface3dEge] = []\n\n    for surface in zonePoly.surfaces:\n        for edge in surface.to_Surface3dEdges():\n            found = False\n            for uniqEdge in uniqueSurface3dEdges:\n                if uniqEdge == edge:\n                    uniqEdge.allSurfaces.append(surface)\n                    found = True\n                    break\n            if not found:\n                uniqueSurface3dEdges.append(edge)\n\n    edgesNotTwoCount = [x for x in uniqueSurface3dEdges if x.count() != 2]\n    edgesTwoCount = [x for x in uniqueSurface3dEdges if x.count() == 2]\n    return edgesNotTwoCount, edgesTwoCount\n</code></pre>"},{"location":"api/#geomeffibem.polyhedron.Polyhedron.get_surface_by_name","title":"<code>get_surface_by_name(name)</code>","text":"<p>Locate a surface by its name.</p> Source code in <code>geomeffibem/polyhedron.py</code> <pre><code>def get_surface_by_name(self, name):\n    \"\"\"Locate a surface by its name.\"\"\"\n    for s in self.surfaces:\n        if s.name is not None and s.name == name:\n            return s\n</code></pre>"},{"location":"api/#geomeffibem.polyhedron.Polyhedron.isEnclosedVolume","title":"<code>isEnclosedVolume()</code>","text":"<p>Checks if the Polyhedron is enclosed, that is all its edges are used exactly twice.</p> Source code in <code>geomeffibem/polyhedron.py</code> <pre><code>def isEnclosedVolume(self) -&gt; Tuple[bool, List[Surface3dEge]]:\n    \"\"\"Checks if the Polyhedron is enclosed, that is all its edges are used exactly twice.\"\"\"\n    edgeNot2orig, _ = Polyhedron.edgesNotTwoForEnclosedVolumeTest(zonePoly=self)\n    if not edgeNot2orig:\n        return True, []\n\n    print(\"Updating Polyhedron with collinear vertices on lines\")\n    updatedZonePoly = self.updateZonePolygonsForMissingColinearPoints()\n    edgeNot2again, _ = Polyhedron.edgesNotTwoForEnclosedVolumeTest(updatedZonePoly)\n    if not edgeNot2again:\n        return True, []\n\n    return False, edgesInBoth(edgeNot2orig, edgeNot2again)\n</code></pre>"},{"location":"api/#geomeffibem.polyhedron.Polyhedron.numVertices","title":"<code>numVertices()</code>","text":"<p>Counts the total number of vertices for all surfaces.</p> Source code in <code>geomeffibem/polyhedron.py</code> <pre><code>def numVertices(self):\n    \"\"\"Counts the total number of vertices for all surfaces.\"\"\"\n    count = 0\n    for s in self.surfaces:\n        count += len(s.vertices)\n    return count\n</code></pre>"},{"location":"api/#geomeffibem.polyhedron.Polyhedron.to_eplus_cpp_code","title":"<code>to_eplus_cpp_code()</code>","text":"<p>For my own convenience when writting EnergyPlus tests.</p> Source code in <code>geomeffibem/polyhedron.py</code> <pre><code>def to_eplus_cpp_code(self):\n    \"\"\"For my own convenience when writting EnergyPlus tests.\"\"\"\n    n_surfaces = len(self.surfaces)\n    print(\n        f\"\"\"\n        Array1D_bool enteredCeilingHeight;\n        state-&gt;dataGlobal-&gt;NumOfZones = 1;\n        enteredCeilingHeight.dimension(state-&gt;dataGlobal-&gt;NumOfZones, false);\n        state-&gt;dataHeatBal-&gt;Zone.allocate(state-&gt;dataGlobal-&gt;NumOfZones);\n        state-&gt;dataHeatBal-&gt;Zone(1).HasFloor = true;\n        state-&gt;dataHeatBal-&gt;Zone(1).HTSurfaceFirst = 1;\n        state-&gt;dataHeatBal-&gt;Zone(1).AllSurfaceFirst = 1;\n        state-&gt;dataHeatBal-&gt;Zone(1).AllSurfaceLast = {n_surfaces};\n\n        state-&gt;dataSurface-&gt;Surface.allocate({n_surfaces});\n        \"\"\"\n    )\n    for i, sf in enumerate(self.surfaces):\n        n_vertices = len(sf.vertices)\n        name = sf.name\n        if 'ROOF' in name:\n            tilt = 0.0\n            c = 'SurfaceClass::Roof'\n        elif 'FLOOR' in name:\n            tilt = 180.0\n            c = 'SurfaceClass::Floor'\n        else:\n            tilt = 90.0\n            c = 'SurfaceClass::Wall'\n\n        print(\n            f'''\n        state-&gt;dataSurface-&gt;Surface({i+1}).Name = \"{name}\";\n        state-&gt;dataSurface-&gt;Surface({i+1}).Sides = {n_vertices};\n        state-&gt;dataSurface-&gt;Surface({i+1}).Vertex.dimension({n_vertices});\n        state-&gt;dataSurface-&gt;Surface({i+1}).Class = {c};\n        state-&gt;dataSurface-&gt;Surface({i+1}).Tilt = {tilt};'''\n        )\n\n        for j, v in enumerate(sf.vertices):\n            print(f\"    state-&gt;dataSurface-&gt;Surface({i+1}).Vertex(1) = Vector({v.x}, {v.y}, {v.z});\")\n</code></pre>"},{"location":"api/#geomeffibem.polyhedron.Polyhedron.to_os_cpp_code","title":"<code>to_os_cpp_code()</code>","text":"<p>For my own convenience when writting OpenStudio tests.</p> Source code in <code>geomeffibem/polyhedron.py</code> <pre><code>def to_os_cpp_code(self):\n    \"\"\"For my own convenience when writting OpenStudio tests.\"\"\"\n    for i, sf in enumerate(self.surfaces):\n        if sf.name is not None:\n            name = sf.name\n        else:\n            name = f\"Surface {i+1}\"\n        if name[1] == '-':\n            cleaned_name = name[2:].lower().replace('-', '')\n        else:\n            cleaned_name = name.lower().replace('-', '')\n        s = \"{\"\n        if sf.name is not None:\n            s += \"\\n \"\n        n_vertices = len(sf.vertices)\n        imax = n_vertices - 1\n        for i, v in enumerate(sf.vertices):\n            if i &gt; 0:\n                s += \" \"\n            s += f\"{{{v.x:+.1f}, {v.y:+.1f}, {v.z:+.1f}}}\"\n            if i &lt; imax:\n                s += \",\\n\"\n        s += \"}\"\n\n        print(f'Surface {cleaned_name}({s}, m);')\n        print(f'{cleaned_name}.setName(\"{name}\");')\n        print(f'{cleaned_name}.setSpace(s);\\n')\n</code></pre>"},{"location":"api/#geomeffibem.polyhedron.Polyhedron.uniqueVertices","title":"<code>uniqueVertices()</code>","text":"<p>Get a list of unique vertices (uses Vertex eq operator which has a tolerance).</p> Source code in <code>geomeffibem/polyhedron.py</code> <pre><code>def uniqueVertices(self) -&gt; List[Vertex]:\n    \"\"\"Get a list of unique vertices (uses Vertex __eq__ operator which has a tolerance).\"\"\"\n    uniqueVertices: List[Vertex] = []\n    for s in self.surfaces:\n        for vertex in s.vertices:\n            found = False\n            for unique_v in uniqueVertices:\n                if unique_v == vertex:\n                    found = True\n                    break\n            if not found:\n                uniqueVertices.append(vertex)\n    return uniqueVertices\n</code></pre>"},{"location":"api/#geomeffibem.polyhedron.Polyhedron.updateZonePolygonsForMissingColinearPoints","title":"<code>updateZonePolygonsForMissingColinearPoints()</code>","text":"<p>Creates a new Polyhedron with extra vertices when a point is found to be on a line segment.</p> Source code in <code>geomeffibem/polyhedron.py</code> <pre><code>def updateZonePolygonsForMissingColinearPoints(self) -&gt; Polyhedron:\n    \"\"\"Creates a new Polyhedron with extra vertices when a point is found to be on a line segment.\"\"\"\n    updZonePoly = copy.deepcopy(self)\n\n    uniqVertices = self.uniqueVertices()\n\n    for surface in updZonePoly.surfaces:\n        insertedVertex = True\n        while insertedVertex:\n            insertedVertex = False\n            for i, edge in enumerate(surface.to_Surface3dEdges()):\n                for testVertex in uniqVertices:\n                    if edge.containsPoints(testVertex):\n                        if i == len(surface.vertices) - 1:\n                            inext = 0\n                        else:\n                            inext = i + 1\n                        surface.vertices.insert(inext, testVertex)\n                        insertedVertex = True\n                        break\n                # Break out of the loop on vertices/edges too, start again at while loop\n                if insertedVertex:\n                    break\n    return updZonePoly\n</code></pre>"},{"location":"api/#geomeffibem.polyhedron.edgesInBoth","title":"<code>edgesInBoth(a, b)</code>","text":"<p>Helper function.</p> Source code in <code>geomeffibem/polyhedron.py</code> <pre><code>def edgesInBoth(a: List[Surface3dEge], b: List[Surface3dEge]) -&gt; List[Surface3dEge]:\n    \"\"\"Helper function.\"\"\"\n    in_both = []\n    for edge_a in a:\n        for edge_b in b:\n            if edge_a == edge_b:\n                in_both.append(edge_a)\n                break\n    return in_both\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#016---2024-11-25","title":"0.1.6 - 2024-11-25","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Dropped support for Python 3.8, updated all other deps. Loosened dependency on OpenStudio.</li> </ul>"},{"location":"changelog/#015---2023-04-14","title":"0.1.5 - 2023-04-14","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Add Surface.Floor and Enforce Upper Left Corner, Counterclockwise convention</li> </ul>"},{"location":"changelog/#014---2023-01-03","title":"0.1.4 - 2023-01-03","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Relax version requirements on openstudio</li> </ul>"},{"location":"changelog/#013---2022-07-12","title":"0.1.3 - 2022-07-12","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Extend with Transformations by @jmarrec in https://github.com/jmarrec/geomeffibem/pull/1</li> </ul>"},{"location":"changelog/#012---2022-05-31","title":"0.1.2 - 2022-05-31","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Minor touches</li> </ul>"},{"location":"changelog/#011---2022-05-31","title":"0.1.1 - 2022-05-31","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Improved coverage significantly and fixed issues identified during testing.</li> <li>Improved documentation for github pages</li> </ul>"},{"location":"changelog/#010---2022-05-30","title":"0.1.0 - 2022-05-30","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>First release on PyPI.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/jmarrec/geomeffibem/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>GeomEffiBEM could always use more documentation, whether as part of the official GeomEffiBEM docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/jmarrec/geomeffibem/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions   are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>geomeffibem</code> for local development.</p> <ol> <li>Fork the <code>geomeffibem</code> repo on GitHub.</li> <li> <p>Clone your fork locally</p> <pre><code>$ git clone git@github.com:your_name_here/geomeffibem.git\n</code></pre> </li> <li> <p>Ensure poetry is installed.</p> </li> <li> <p>Install dependencies and start your virtualenv:</p> <pre><code>$ poetry install -E test -E doc -E dev\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass the    tests, including testing other Python versions, with tox:</p> <pre><code>$ poetry run tox\n</code></pre> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put    your new functionality into a function with a docstring, and add the    feature to the list in README.md.</li> <li>The pull request should work for Python 3.6, 3.7, 3.8 and 3.9. Check    https://github.com/jmarrec/geomeffibem/actions    and make sure that the tests pass for all supported Python versions.</li> </ol>"},{"location":"contributing/#tips","title":"Tips","text":"<pre><code>$ poetry run pytest tests/test_vertex.py\n</code></pre> <p>To run a subset of tests.</p>"},{"location":"contributing/#deploying","title":"Deploying","text":"<p>A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md). Then run:</p> <pre><code>$ poetry run bump2version patch # possible: major / minor / patch\n$ git push\n$ git push --tags\n</code></pre> <p>GitHub Actions will then deploy to PyPI if tests pass.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install GeomEffiBEM, run this command in your terminal:</p> <pre><code>$ pip install geomeffibem\n</code></pre> <p>This is the preferred method to install GeomEffiBEM, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-source","title":"From source","text":"<p>The source for GeomEffiBEM can be downloaded from the Github repo.</p> <p>You can either clone the public repository:</p> <pre><code>$ git clone git://github.com/jmarrec/geomeffibem\n</code></pre> <p>Or download the tarball:</p> <pre><code>$ curl -OJL https://github.com/jmarrec/geomeffibem/tarball/master\n</code></pre> <p>Once you have a copy of the source, you can install it with:</p> <pre><code>$ pip install .\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#usage","title":"Usage","text":"<p>To use GeomEffiBEM in a project</p> <pre><code>import geomeffibem\n</code></pre>"}]}